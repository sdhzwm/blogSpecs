---
title: APP启动速度优化与监控笔记
date: 2020-09-12 22:29:26
categories: [技术人生,读书笔记]
tags: [iOS性能,启动优化]
---

APP 启动速度优化，一度在开发过程中是不怎么重视的需求之一。然而在市场竞争逐渐热化的当下，APP 中任何能够提升用户体验的方向都很值得程序员们进一步的探索和研究。戴铭在极客时间的专栏中提到这样案例：

假设你在排队结账时，掏出手机打开 App 甲准备扫码支付，结果半天进不去，后面排队的人给你压力够大吧。然后，你又打开 App 乙，秒进，支付完成。试想一下，以后再支付时你会选择哪个 App 呢。不难想象，在提供的功能和服务相似的情况下，一款 App 的启动速度，不单单是用户体验的事情，往往还决定了它能否获取更多的用户。这就好像陌生人第一次碰面，第一感觉往往决定了他们接下来是否会继续交往。

由此可见，启动速度的优化必然就是 App 开发过程中，不可或缺的一个环节。

<!--more -->

## 启动类型

一般情况下，App 的启动分为冷启动和热启动。

- Cold ：App 重启后启动，不在内存里也没有进程存在，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程
- Warm：App最近结束后再启动，有部分内存，但没有进程存在
- Resume：App没结束，只是暂停，全在内存中，存在进程。

用户能感知到的启动慢，其实都发生在主线程上。而主线程慢的原因有很多，比如在主线程上执行了大文件读写操作、在渲染周期中执行了大量计算等。所以我们更多的方法调用就应该做成按需执行，将启动压力分摊，只留下那些启动后方法都会依赖的方法和库的初始化，比如网络库、Crash 库等。而剩下那些需要预加载的功能可以放到启动阶段后再执行。

## APP启动阶段

App 的启动时间，指的是**从用户点击 App 开始，到用户看到第一个界面之间的时间**。总结来说，App 的启动主要包括三个阶段：

- main() 函数执行前；
- main() 函数执行后；
- 首屏渲染完成后。

### main() 函数执行前

该阶段，系统主要会做下面几件事情：

- 加载可执行文件（App 的.o 文件的集合）
- 加载动态链接库，进行 `rebase` 指针调整和 `bind` 符号绑定；
- Objc 运行时的初始处理，包括 Objc 相关类的注册、`category` 注册、`selector` 唯一性检查等；
- 初始化，包括了执行 ``+load()`` 方法、`attribute((constructor))`` 修饰的函数的调用、创建 C++ 静态全局变量。

相应地，这个阶段对于启动速度优化来说，可以做的事情包括：

- 减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议**在使用动态库的数量较多时，尽量将多个动态库进行合并**。数量上，**苹果公司建议最多使用 6 个非系统动态库**。
- **减少加载启动后不会去使用的类或者方法**。
- **``+load()`` 方法里的内容可以放到首屏渲染完成后再执行，或使用 ``+initialize()`` 方法替换掉**。因为，在一个 ``+load()`` 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 ``+load() `方法对启动速度的影响会越来越大。
- 控制 C++ 全局变量的数量。

### main() 函数执行后

`main()` 函数执行后的阶段，指的是从 `main()` 函数执行开始，到 `appDelegate` 的 `didFinishLaunchingWithOptions` 方法里首屏渲染相关方法执行完成。也就是说从`main()`函数执行后到  `launchdidfinish` 结束前，都属于首屏渲染。

首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括了：

- 首屏初始化所需配置文件的读写操作；
- 首屏列表大数据的读取；
- 首屏渲染的大量计算等。

很多时候，开发者会把各种初始化工作都放到这个阶段执行，导致渲染完成滞后。更加优化的开发方式，应该是**从功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是 App 启动必要的初始化功能，而哪些是只需要在对应功能开始使用时才需要初始化的**。梳理完之后，将这些初始化功能分别放到合适的阶段进行。例如将方法调用做成按需执行，把压力分摊，只留下启动后方法都会依赖的方法和库。比如网络库、Crash库，需要预加载的功能就放到启动阶段后再执行。

### 首屏渲染完成后

首屏渲染后的这个阶段，主要完成的是，**非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等**。
从函数上来看，这个阶段指的就是截止到 `didFinishLaunchingWithOptions` 方法作用域内执行首屏渲染之后的所有方法执行完成。简单说的话，这个阶段就是从渲染完成时开始，到 `didFinishLaunchingWithOptions` 方法作用域结束时结束。

明白了 App 启动阶段需要完成的工作后，我们就可以有的放矢地进行启动速度的优化了。这些优化，包括了功能级别和方法级别的启动优化。

### 功能级优化

功能级别的启动优化，就是要从 `main()` 函数执行后这个阶段下手。

优化的思路是： `main()` 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。

### 方法级优化

接下来，我们需要进一步做的，是检查首屏渲染完成前主线程上有哪些耗时方法，将没必要的耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，**具体的表现就是加载、编辑、存储图片和文件等资源**。

然而任务延后的处理不能粗犷的一口气在启动完成后在主线程一起执行，那样用户仅仅只是看到了页面，依然没法响应操作。那该怎么做呢？一般是创建四个队列，分别是：

- 异步串行队列
- 异步并行队列
- 闲时主线程串行队列
- 闲时异步串行队列

**有依赖关系的任务可以放到异步串行队列中执行**。
异步并行队列可以分组执行，比如使用 `dispatch_group`，然后对每组任务数量进行限制，避免 CPU、线程和内存瞬时激增影响主线程用户操作，定义有限数量的串行队列，每个串行队列做特定的事情，这样也能够避免性能消耗短时间突然暴涨引起无法响应用户操作。
使用 `dispatch_semaphore_t` 在信号量阻塞主队列时容易出现优先级反转，需要减少使用，确保 `QoS` 传播。可以用 `dispatch group` 替代，性能一样，功能不差。异步编程可以直接 `GCD` 接口来写，也可以使用阿里的协程框架

[coobjc GitHub - alibaba/coobjc](https://github.com/alibaba/coobjc)  

闲时队列实现方式是监听主线程 `runloop` 状态，在 `kCFRunLoopBeforeWaiting` 时开始执行闲时队列里的任务，在 `kCFRunLoopAfterWaiting` 时停止。

## App 启动速度的监控

目前来看，对 App 启动速度的监控，主要有两种手段。

- 第一种方法是，定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时。
- 第二种方法是，对 `objc_msgSend` 方法进行 `hook` 来掌握所有方法的执行耗时。

### Time Profiler

Xcode 工具套件 `Instruments` 里自带的 `Time Profiler` 采用的就是这种方式。

这种方式的优点是，开发类似工具成本不高，能够快速开发后集成到 App 中，以便在真实环境中进行检查。

说到定时抓取，就会涉及到定时间隔的长短问题。

- 定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确；
- 而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确。

**一般将这个定时间隔设置为 0.01 秒。这样设置，对整体耗时的影响小，不过很多方法耗时就不精确了**。但因为整体耗时的数据更加重要些，单个方法耗时精度不高也是可以接受的，所以这个设置也是没问题的。

总结来说，定时抓取主线程调用栈的方式虽然精准度不够高，但也是够用的。

### 用 `objc_msgSend` 方法进行 `hook`

`hook` 方法的意思是，在原方法开始执行时换成执行其他你指定的方法，或者在原有方法执行前后执行你指定的方法，来达到掌握和改变指定方法的目的。

`hook objc_msgSend` 这种方式的优点是非常精确，而缺点是只能针对 Objective-C 的方法。当然，对于 c 方法和 block 也不是没有办法，你可以使用 `libffi` 的 `ffi_call` 来达成 `hook`，但缺点就是编写维护相关工具门槛高。

如果对于检查结果精准度要求高的话，比较使用 `hook` `objc_msgSend` 方式来检查启动方法的执行耗时。

**为什么`hook 了 objc_msgSend` 方法,可以 `hook` 全部 Objective-C 的方法？**

Objective-C 里每个对象都会指向一个类，每个类都会有一个方法列表，方法列表里的每个方法都是由 `selector`、`函数指针和` `metadata` 组成的。

`objc_msgSend` 方法干的活儿，就是在运行时根据对象和方法的 `selector` 去找到对应的函数指针，然后执行。也就是说，`objc_msgSend` 是 Objective-C 里方法执行的必经之路，能够控制所有的 Objective-C 的方法。

`objc_msgSend` 本身是用汇编语言写的，这样做的原因主要有两个：

- 一个原因是，`objc_msgSend` 的调用频次最高，在它上面进行的性能优化能够提升整个 App 生命周期的性能。而汇编语言在性能优化上属于原子级优化，能够把优化做到极致。所以，这种投入产出比无疑是最大的。
- 另一个原因是，其他语言难以实现未知参数跳转到任意函数指针的功能。

详细参见 [苹果公司开源网站](https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/) 查看 `objc_msgSend` 源码：
![[Pasted image 20210413143919.png]]

`objc_msgSend` 是 iOS 方式执行最核心的部分，编程领域的宝藏。`objc_msgSend` 方法执行的逻辑是：**先获取对象对应类的信息，再获取方法的缓存，根据方法的 `selector` 查找函数指针，经过异常错误处理后，最后跳到对应函数的实现**。

## 小结

本文主要为 [高德APP启动耗时剖析与优化实践（iOS篇）-InfoQ](https://www.infoq.cn/article/xJb3CYSClpHV5sh5923q) 和 [戴铭: App 启动速度怎么做优化与监控？](https://time.geekbang.org/column/article/85331) 两文的笔记整理。从两文看来，APP 启动速度优化，对于技术人员来讲，不单单是提升启动速度，还是对技术人员技术积累，开发团队协作要求的考验。

当然APP优化，非一日之工，然行则将至，行而不辍，或可未来可期。

## 参考资料

- [戴铭: App 启动速度怎么做优化与监控？](https://time.geekbang.org/column/article/85331)
- [高德APP启动耗时剖析与优化实践（iOS篇）-InfoQ](https://www.infoq.cn/article/xJb3CYSClpHV5sh5923q)
- [苹果公司开源网站](https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/)
- [2019 年 WWDC 启动优化专题]([https://developer.apple.com/videos/play/wwdc2019/423/](https://developer.apple.com/videos/play/wwdc2019/423/))
- [Using Time Profiler in Instruments - WWDC 2016 - Videos - Apple Developer](https://developer.apple.com/videos/play/wwdc2016/418/)  
- [Optimizing I/O for Performance and Battery Life - WWDC 2016 - Videos - Apple Developer](https://developer.apple.com/videos/play/wwdc2016/719/)  
- [Optimizing App Startup Time - WWDC 2016 - Videos - Apple Developer](https://developer.apple.com/videos/play/wwdc2016/406/)  
- [App Startup Time: Past, Present, and Future - WWDC 2017 - Videos - Apple Developer](https://developer.apple.com/videos/play/wwdc2017/413/)
